{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "clean-ui-components",
  "type": "registry:block",
  "title": "Clean UI Components",
  "description": "Clean, professional UI components that replace MagicUI animations.",
  "files": [
    {
      "path": "src/components/ui/animated-gradient-text.tsx",
      "content": "\"use client\";\r\n\r\nimport React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nconst gradientTextVariants = cva(\r\n  \"bg-clip-text text-transparent bg-gradient-to-r font-bold\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        primary: \"from-primary to-primary/70\",\r\n        secondary: \"from-secondary to-secondary/70\",\r\n        accent: \"from-accent to-accent/70\",\r\n        destructive: \"from-destructive to-destructive/70\",\r\n        blue: \"from-blue-600 to-blue-400\",\r\n        purple: \"from-purple-600 to-purple-400\",\r\n        green: \"from-green-600 to-green-400\",\r\n        amber: \"from-amber-600 to-amber-400\",\r\n        pink: \"from-pink-600 to-pink-400\",\r\n      },\r\n      size: {\r\n        xs: \"text-xs\",\r\n        sm: \"text-sm\",\r\n        md: \"text-base\",\r\n        lg: \"text-lg\",\r\n        xl: \"text-xl\",\r\n        \"2xl\": \"text-2xl\",\r\n        \"3xl\": \"text-3xl\",\r\n        \"4xl\": \"text-4xl\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"primary\",\r\n      size: \"md\",\r\n    },\r\n  }\r\n);\r\n\r\ninterface GradientTextProps\r\n  extends React.HTMLAttributes<HTMLSpanElement>,\r\n    VariantProps<typeof gradientTextVariants> {\r\n  text: string;\r\n}\r\n\r\n/**\r\n * GradientText - A clean text component with gradient styling\r\n *\r\n * This component replaces the AnimatedGradientText with a simpler,\r\n * non-animated version that still provides visual appeal through gradients.\r\n *\r\n * @example\r\n * <GradientText text=\"Hello World\" variant=\"primary\" size=\"2xl\" />\r\n */\r\nexport function GradientText({\r\n  text,\r\n  className,\r\n  variant,\r\n  size,\r\n  ...props\r\n}: GradientTextProps) {\r\n  return (\r\n    <span\r\n      className={cn(gradientTextVariants({ variant, size }), className)}\r\n      {...props}\r\n    >\r\n      {text}\r\n    </span>\r\n  );\r\n}\r\n\r\n// For backward compatibility\r\nexport const AnimatedGradientText = GradientText;\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/shine-border.tsx",
      "content": "\"use client\";\r\n\r\nimport React from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nconst borderVariants = cva(\r\n  \"relative border overflow-hidden\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"border-border\",\r\n        primary: \"border-primary/50\",\r\n        secondary: \"border-secondary/50\",\r\n        accent: \"border-accent/50\",\r\n        destructive: \"border-destructive/50\",\r\n      },\r\n      rounded: {\r\n        none: \"rounded-none\",\r\n        sm: \"rounded-sm\",\r\n        md: \"rounded-md\",\r\n        lg: \"rounded-lg\",\r\n        xl: \"rounded-xl\",\r\n        \"2xl\": \"rounded-2xl\",\r\n        full: \"rounded-full\",\r\n      },\r\n      borderWidth: {\r\n        thin: \"border\",\r\n        medium: \"border-2\",\r\n        thick: \"border-4\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      rounded: \"lg\",\r\n      borderWidth: \"thin\",\r\n    },\r\n  }\r\n);\r\n\r\ninterface BorderContainerProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof borderVariants> {\r\n  children: React.ReactNode;\r\n  borderRadius?: string; // For backward compatibility\r\n}\r\n\r\n/**\r\n * BorderContainer - A clean border container component\r\n *\r\n * This component replaces the ShineBorder with a simpler,\r\n * non-animated version that still provides visual appeal through\r\n * clean borders with various styling options.\r\n *\r\n * @example\r\n * <BorderContainer variant=\"primary\" rounded=\"xl\" borderWidth=\"medium\">\r\n *   <div>Content</div>\r\n * </BorderContainer>\r\n */\r\nexport function BorderContainer({\r\n  children,\r\n  className,\r\n  variant,\r\n  rounded,\r\n  borderWidth,\r\n  borderRadius,\r\n  ...props\r\n}: BorderContainerProps) {\r\n  // Apply inline style for borderRadius if provided (for backward compatibility)\r\n  const style = borderRadius ? { borderRadius } : undefined;\r\n\r\n  return (\r\n    <div\r\n      className={cn(\r\n        borderVariants({ variant, rounded, borderWidth }),\r\n        className\r\n      )}\r\n      style={style}\r\n      {...props}\r\n    >\r\n      <div className=\"relative z-10\">{children}</div>\r\n    </div>\r\n  );\r\n}\r\n\r\n// For backward compatibility\r\nexport function ShineBorder({\r\n  children,\r\n  borderColor,\r\n  shineBorderColor,\r\n  borderRadius = \"0.5rem\",\r\n  className = \"\",\r\n  duration,\r\n  ...props\r\n}: ShineBorderProps) {\r\n  return (\r\n    <BorderContainer\r\n      variant=\"primary\"\r\n      borderRadius={borderRadius}\r\n      className={className}\r\n      {...props}\r\n    >\r\n      {children}\r\n    </BorderContainer>\r\n  );\r\n}\r\n\r\n// For backward compatibility\r\ninterface ShineBorderProps {\r\n  children: React.ReactNode;\r\n  borderColor?: string;\r\n  shineBorderColor?: string;\r\n  borderRadius?: string;\r\n  className?: string;\r\n  duration?: number;\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/grid-pattern.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface GridPatternProps extends React.HTMLAttributes<HTMLDivElement> {\n  gridSize?: number;\n  lineColor?: string;\n  lineOpacity?: number;\n  lineWidth?: number;\n  className?: string;\n}\n\n/**\n * GridPattern - A clean grid pattern background component\n * \n * This component replaces the AnimatedGridPattern with a simpler,\n * non-animated version that still provides visual appeal.\n * \n * @example\n * <GridPattern \n *   gridSize={40} \n *   lineColor=\"#000000\" \n *   lineOpacity={0.1} \n *   lineWidth={1} \n * />\n */\nexport function GridPattern({\n  gridSize = 40,\n  lineColor = \"currentColor\",\n  lineOpacity = 0.1,\n  lineWidth = 1,\n  className,\n  ...props\n}: GridPatternProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Set canvas dimensions to match parent\n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        if (entry.target === canvas) {\n          const { width, height } = entry.contentRect;\n          canvas.width = width;\n          canvas.height = height;\n          drawGrid();\n        }\n      }\n    });\n\n    resizeObserver.observe(canvas);\n\n    // Draw the grid\n    function drawGrid() {\n      if (!ctx || !canvas) return;\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Set line style\n      ctx.strokeStyle = lineColor;\n      ctx.globalAlpha = lineOpacity;\n      ctx.lineWidth = lineWidth;\n\n      // Calculate grid\n      const numCols = Math.ceil(canvas.width / gridSize);\n      const numRows = Math.ceil(canvas.height / gridSize);\n\n      // Draw vertical lines\n      for (let i = 0; i <= numCols; i++) {\n        const x = i * gridSize;\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvas.height);\n        ctx.stroke();\n      }\n\n      // Draw horizontal lines\n      for (let i = 0; i <= numRows; i++) {\n        const y = i * gridSize;\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvas.width, y);\n        ctx.stroke();\n      }\n    }\n\n    // Initial draw\n    drawGrid();\n\n    // Clean up\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [gridSize, lineColor, lineOpacity, lineWidth]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={cn(\"absolute inset-0 w-full h-full\", className)}\n      {...props}\n    />\n  );\n}\n\n// For backward compatibility\nexport const AnimatedGridPattern = GridPattern;\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/scroll-progress.tsx",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useState } from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nconst progressVariants = cva(\r\n  \"fixed top-0 left-0 right-0 h-1 bg-transparent\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"\",\r\n        primary: \"\",\r\n        secondary: \"\",\r\n        accent: \"\",\r\n        destructive: \"\",\r\n      },\r\n      size: {\r\n        sm: \"h-0.5\",\r\n        md: \"h-1\",\r\n        lg: \"h-1.5\",\r\n        xl: \"h-2\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"primary\",\r\n      size: \"md\",\r\n    },\r\n  }\r\n);\r\n\r\ninterface ScrollProgressProps\r\n  extends React.HTMLAttributes<HTMLDivElement>,\r\n    VariantProps<typeof progressVariants> {\r\n  color?: string;\r\n  height?: number;\r\n  zIndex?: number;\r\n}\r\n\r\n/**\r\n * ScrollProgress - A clean scroll progress indicator\r\n *\r\n * This component shows a progress bar at the top of the page\r\n * that indicates how far the user has scrolled.\r\n *\r\n * @example\r\n * <ScrollProgress variant=\"primary\" size=\"md\" />\r\n */\r\nexport function ScrollProgress({\r\n  className,\r\n  variant,\r\n  size,\r\n  color,\r\n  height,\r\n  zIndex = 50,\r\n  ...props\r\n}: ScrollProgressProps) {\r\n  const [scrollProgress, setScrollProgress] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const handleScroll = () => {\r\n      const totalHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;\r\n      const progress = (window.scrollY / totalHeight) * 100;\r\n      setScrollProgress(progress);\r\n    };\r\n\r\n    // Add scroll event listener\r\n    window.addEventListener(\"scroll\", handleScroll);\r\n\r\n    // Initial calculation\r\n    handleScroll();\r\n\r\n    // Clean up\r\n    return () => {\r\n      window.removeEventListener(\"scroll\", handleScroll);\r\n    };\r\n  }, []);\r\n\r\n  // Determine the color based on variant\r\n  const getBarColor = () => {\r\n    if (color) return color;\r\n\r\n    switch (variant) {\r\n      case \"primary\":\r\n        return \"var(--primary)\";\r\n      case \"secondary\":\r\n        return \"var(--secondary)\";\r\n      case \"accent\":\r\n        return \"var(--accent)\";\r\n      case \"destructive\":\r\n        return \"var(--destructive)\";\r\n      default:\r\n        return \"var(--primary)\";\r\n    }\r\n  };\r\n\r\n  // Determine the height based on size or height prop\r\n  const getHeight = () => {\r\n    if (height) return `${height}px`;\r\n    return undefined; // Let the CSS classes handle it\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={cn(progressVariants({ variant, size }), className)}\r\n      style={{\r\n        zIndex,\r\n        height: getHeight(),\r\n      }}\r\n      {...props}\r\n    >\r\n      <div\r\n        className=\"h-full transition-all duration-200 ease-out\"\r\n        style={{\r\n          width: `${scrollProgress}%`,\r\n          backgroundColor: getBarColor(),\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/focus-ring.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nconst focusRingVariants = cva(\n  \"pointer-events-none absolute inset-0 select-none rounded-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border border-border/50\",\n        primary: \"border border-primary/50\",\n        secondary: \"border border-secondary/50\",\n        accent: \"border border-accent/50\",\n        destructive: \"border border-destructive/50\",\n      },\n      size: {\n        sm: \"w-24 h-24\",\n        md: \"w-32 h-32\",\n        lg: \"w-40 h-40\",\n        xl: \"w-48 h-48\",\n        \"2xl\": \"w-56 h-56\",\n      },\n      opacity: {\n        low: \"opacity-10\",\n        medium: \"opacity-20\",\n        high: \"opacity-30\",\n      },\n    },\n    defaultVariants: {\n      variant: \"primary\",\n      size: \"lg\",\n      opacity: \"medium\",\n    },\n  }\n);\n\ninterface FocusRingProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof focusRingVariants> {\n  numRings?: number;\n}\n\n/**\n * FocusRing - A clean focus ring component\n * \n * This component provides a visual focus indicator with concentric rings.\n * It replaces the Ripple component with a cleaner, non-animated version.\n * \n * @example\n * <FocusRing variant=\"primary\" size=\"lg\" opacity=\"medium\" numRings={3} />\n */\nexport function FocusRing({\n  className,\n  variant,\n  size,\n  opacity,\n  numRings = 3,\n  ...props\n}: FocusRingProps) {\n  return (\n    <div\n      className={cn(\n        \"pointer-events-none absolute inset-0 select-none\",\n        className\n      )}\n      {...props}\n    >\n      {Array.from({ length: numRings }, (_, i) => {\n        const scale = 1 + i * 0.2;\n        \n        return (\n          <div\n            key={i}\n            className={cn(\n              focusRingVariants({ variant, size, opacity }),\n              \"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2\"\n            )}\n            style={{\n              transform: `translate(-50%, -50%) scale(${scale})`,\n              opacity: 1 - i * 0.2,\n              zIndex: numRings - i,\n            }}\n          />\n        );\n      })}\n    </div>\n  );\n}\n\n// For backward compatibility\ninterface RippleProps extends React.ComponentPropsWithoutRef<\"div\"> {\n  mainCircleSize?: number;\n  mainCircleOpacity?: number;\n  numCircles?: number;\n}\n\nexport function Ripple({\n  mainCircleSize = 210,\n  mainCircleOpacity = 0.24,\n  numCircles = 8,\n  className,\n  ...props\n}: RippleProps) {\n  // Map the Ripple props to FocusRing props\n  const size = mainCircleSize <= 150 ? \"sm\" : \n               mainCircleSize <= 200 ? \"md\" : \n               mainCircleSize <= 250 ? \"lg\" : \n               mainCircleSize <= 300 ? \"xl\" : \"2xl\";\n               \n  const opacity = mainCircleOpacity <= 0.15 ? \"low\" : \n                 mainCircleOpacity <= 0.25 ? \"medium\" : \"high\";\n                 \n  return (\n    <FocusRing\n      variant=\"primary\"\n      size={size}\n      opacity={opacity}\n      numRings={Math.min(numCircles, 5)}\n      className={className}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/text-rotate.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useEffect } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nconst textRotateVariants = cva(\n  \"inline-block transition-all duration-300\",\n  {\n    variants: {\n      variant: {\n        default: \"text-foreground\",\n        primary: \"text-primary\",\n        secondary: \"text-secondary\",\n        accent: \"text-accent\",\n        destructive: \"text-destructive\",\n        muted: \"text-muted-foreground\",\n      },\n      weight: {\n        normal: \"font-normal\",\n        medium: \"font-medium\",\n        semibold: \"font-semibold\",\n        bold: \"font-bold\",\n      },\n      size: {\n        xs: \"text-xs\",\n        sm: \"text-sm\",\n        md: \"text-base\",\n        lg: \"text-lg\",\n        xl: \"text-xl\",\n        \"2xl\": \"text-2xl\",\n        \"3xl\": \"text-3xl\",\n      },\n    },\n    defaultVariants: {\n      variant: \"primary\",\n      weight: \"bold\",\n      size: \"lg\",\n    },\n  }\n);\n\ninterface TextRotateProps\n  extends React.HTMLAttributes<HTMLSpanElement>,\n    VariantProps<typeof textRotateVariants> {\n  words: string[];\n  interval?: number;\n}\n\n/**\n * TextRotate - A clean text rotation component\n * \n * This component cycles through a list of words with a clean transition.\n * It replaces the WordRotate component with a simpler, cleaner version.\n * \n * @example\n * <TextRotate \n *   words={[\"Developer\", \"Designer\", \"Creator\"]} \n *   variant=\"primary\" \n *   weight=\"bold\" \n *   size=\"xl\" \n *   interval={3000} \n * />\n */\nexport function TextRotate({\n  className,\n  variant,\n  weight,\n  size,\n  words,\n  interval = 3000,\n  ...props\n}: TextRotateProps) {\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [isVisible, setIsVisible] = useState(true);\n\n  useEffect(() => {\n    if (words.length <= 1) return;\n\n    const rotationInterval = setInterval(() => {\n      setIsVisible(false);\n      \n      setTimeout(() => {\n        setCurrentIndex((prevIndex) => (prevIndex + 1) % words.length);\n        setIsVisible(true);\n      }, 300); // Match the transition duration\n    }, interval);\n\n    return () => clearInterval(rotationInterval);\n  }, [words, interval]);\n\n  return (\n    <span\n      className={cn(\n        textRotateVariants({ variant, weight, size }),\n        isVisible ? \"opacity-100\" : \"opacity-0\",\n        \"transform\",\n        isVisible ? \"translate-y-0\" : \"translate-y-2\",\n        className\n      )}\n      {...props}\n    >\n      {words[currentIndex]}\n    </span>\n  );\n}\n\n// For backward compatibility\ninterface WordRotateProps {\n  words: string[];\n  duration?: number;\n  motionProps?: any;\n  className?: string;\n}\n\nexport function WordRotate({\n  words,\n  duration = 2500,\n  className,\n  ...props\n}: WordRotateProps) {\n  return (\n    <TextRotate\n      words={words}\n      interval={duration}\n      className={className}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/number-display.tsx",
      "content": "\"use client\";\n\nimport React, { useState, useEffect } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\n\nconst numberDisplayVariants = cva(\n  \"inline-block transition-all duration-300\",\n  {\n    variants: {\n      variant: {\n        default: \"text-foreground\",\n        primary: \"text-primary\",\n        secondary: \"text-secondary\",\n        accent: \"text-accent\",\n        destructive: \"text-destructive\",\n        muted: \"text-muted-foreground\",\n      },\n      weight: {\n        normal: \"font-normal\",\n        medium: \"font-medium\",\n        semibold: \"font-semibold\",\n        bold: \"font-bold\",\n      },\n      size: {\n        xs: \"text-xs\",\n        sm: \"text-sm\",\n        md: \"text-base\",\n        lg: \"text-lg\",\n        xl: \"text-xl\",\n        \"2xl\": \"text-2xl\",\n        \"3xl\": \"text-3xl\",\n      },\n    },\n    defaultVariants: {\n      variant: \"primary\",\n      weight: \"bold\",\n      size: \"lg\",\n    },\n  }\n);\n\ninterface NumberDisplayProps\n  extends React.HTMLAttributes<HTMLSpanElement>,\n    VariantProps<typeof numberDisplayVariants> {\n  value: number;\n  duration?: number;\n  prefix?: string;\n  suffix?: string;\n  decimals?: number;\n}\n\n/**\n * NumberDisplay - A clean number display component\n * \n * This component displays a number with a smooth transition when it changes.\n * It replaces the NumberTicker component with a simpler, cleaner version.\n * \n * @example\n * <NumberDisplay \n *   value={1234} \n *   variant=\"primary\" \n *   weight=\"bold\" \n *   size=\"xl\" \n *   prefix=\"$\" \n *   decimals={2} \n * />\n */\nexport function NumberDisplay({\n  className,\n  variant,\n  weight,\n  size,\n  value,\n  duration = 1000,\n  prefix = \"\",\n  suffix = \"\",\n  decimals = 0,\n  ...props\n}: NumberDisplayProps) {\n  const [displayValue, setDisplayValue] = useState(value);\n  const [isAnimating, setIsAnimating] = useState(false);\n\n  useEffect(() => {\n    if (value === displayValue) return;\n    \n    setIsAnimating(true);\n    \n    // Calculate step size based on the difference and duration\n    const diff = value - displayValue;\n    const steps = Math.min(30, Math.abs(diff)); // Max 30 steps for performance\n    const stepValue = diff / steps;\n    const stepDuration = duration / steps;\n    \n    let currentStep = 0;\n    let currentValue = displayValue;\n    \n    const interval = setInterval(() => {\n      currentStep++;\n      \n      if (currentStep >= steps) {\n        setDisplayValue(value);\n        setIsAnimating(false);\n        clearInterval(interval);\n      } else {\n        currentValue += stepValue;\n        setDisplayValue(currentValue);\n      }\n    }, stepDuration);\n    \n    return () => clearInterval(interval);\n  }, [value, displayValue, duration]);\n\n  // Format the number with the specified number of decimal places\n  const formattedValue = displayValue.toLocaleString(undefined, {\n    minimumFractionDigits: decimals,\n    maximumFractionDigits: decimals,\n  });\n\n  return (\n    <span\n      className={cn(\n        numberDisplayVariants({ variant, weight, size }),\n        isAnimating ? \"opacity-100\" : \"opacity-100\", // Always visible, but could add subtle effects\n        className\n      )}\n      {...props}\n    >\n      {prefix}{formattedValue}{suffix}\n    </span>\n  );\n}\n\n// For backward compatibility\ninterface NumberTickerProps {\n  value: number;\n  duration?: number;\n  prefix?: string;\n  suffix?: string;\n  decimals?: number;\n  className?: string;\n}\n\nexport function NumberTicker({\n  value,\n  duration = 1000,\n  prefix = \"\",\n  suffix = \"\",\n  decimals = 0,\n  className,\n  ...props\n}: NumberTickerProps) {\n  return (\n    <NumberDisplay\n      value={value}\n      duration={duration}\n      prefix={prefix}\n      suffix={suffix}\n      decimals={decimals}\n      className={className}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/dot-background.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface DotBackgroundProps extends React.HTMLAttributes<HTMLDivElement> {\n  dotSize?: number;\n  dotSpacing?: number;\n  dotColor?: string;\n  dotOpacity?: number;\n}\n\n/**\n * DotBackground - A clean dot pattern background component\n * \n * This component creates a background with a pattern of dots.\n * It replaces the DotPattern component with a simpler, non-animated version.\n * \n * @example\n * <DotBackground \n *   dotSize={2} \n *   dotSpacing={20} \n *   dotColor=\"currentColor\" \n *   dotOpacity={0.2} \n * />\n */\nexport function DotBackground({\n  className,\n  dotSize = 2,\n  dotSpacing = 20,\n  dotColor = \"currentColor\",\n  dotOpacity = 0.2,\n  ...props\n}: DotBackgroundProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    // Set canvas dimensions to match parent\n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        if (entry.target === canvas) {\n          const { width, height } = entry.contentRect;\n          canvas.width = width;\n          canvas.height = height;\n          drawDots();\n        }\n      }\n    });\n\n    resizeObserver.observe(canvas);\n\n    // Draw the dots\n    function drawDots() {\n      if (!ctx || !canvas) return;\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Set dot style\n      ctx.fillStyle = dotColor;\n      ctx.globalAlpha = dotOpacity;\n\n      // Calculate grid\n      const numCols = Math.ceil(canvas.width / dotSpacing);\n      const numRows = Math.ceil(canvas.height / dotSpacing);\n\n      // Draw dots\n      for (let i = 0; i <= numCols; i++) {\n        for (let j = 0; j <= numRows; j++) {\n          const x = i * dotSpacing;\n          const y = j * dotSpacing;\n          \n          ctx.beginPath();\n          ctx.arc(x, y, dotSize / 2, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n\n    // Initial draw\n    drawDots();\n\n    // Clean up\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [dotSize, dotSpacing, dotColor, dotOpacity]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={cn(\"absolute inset-0 w-full h-full\", className)}\n      {...props}\n    />\n  );\n}\n\n// For backward compatibility\ninterface DotPatternProps extends React.ComponentPropsWithoutRef<\"svg\"> {\n  width?: number;\n  height?: number;\n  x?: number;\n  y?: number;\n  cx?: number;\n  cy?: number;\n  cr?: number;\n  glow?: boolean;\n}\n\nexport function DotPattern({\n  width = 16,\n  height = 16,\n  cx = 1,\n  cy = 1,\n  cr = 1,\n  className,\n  glow = false,\n  ...props\n}: DotPatternProps) {\n  return (\n    <DotBackground\n      dotSize={cr * 2}\n      dotSpacing={Math.max(width, height)}\n      dotOpacity={glow ? 0.3 : 0.2}\n      className={className}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}