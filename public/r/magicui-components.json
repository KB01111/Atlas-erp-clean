{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "magicui-components",
  "type": "registry:block",
  "title": "MagicUI Components",
  "description": "Enhanced UI components from MagicUI for Atlas-ERP.",
  "files": [
    {
      "path": "src/components/ui/animated-gradient-text.tsx",
      "content": "\"use client\";\r\n\r\nimport { useEffect, useRef, memo, useCallback } from \"react\";\r\nimport { usePerformanceOptimization } from \"@/hooks/usePerformanceOptimization\";\r\n\r\ninterface AnimatedGradientTextProps {\r\n  text: string;\r\n  className?: string;\r\n  gradient?: string;\r\n  duration?: number;\r\n}\r\n\r\n// Add global keyframes style only once with slower animation\r\nif (typeof document !== 'undefined' && !document.querySelector(\"#gradient-animation-keyframes\")) {\r\n  try {\r\n    const style = document.createElement(\"style\");\r\n    style.id = \"gradient-animation-keyframes\";\r\n    style.textContent = `\r\n      @keyframes gradient-animation {\r\n        0% {\r\n          background-position: 0% center;\r\n        }\r\n        100% {\r\n          background-position: 200% center;\r\n        }\r\n      }\r\n\r\n      @media (prefers-reduced-motion: reduce) {\r\n        .animated-gradient-text {\r\n          animation: none !important;\r\n        }\r\n      }\r\n    `;\r\n    document.head.appendChild(style);\r\n    console.log(\"Added gradient animation keyframes\");\r\n  } catch (error) {\r\n    console.error(\"Failed to add gradient animation keyframes:\", error);\r\n  }\r\n}\r\n\r\n// Memoize the component to prevent unnecessary re-renders\r\nexport const AnimatedGradientText = memo(function AnimatedGradientText({\r\n  text,\r\n  className = \"\",\r\n  gradient = \"linear-gradient(to right, #3b82f6, #8b5cf6)\",\r\n  duration = 8,\r\n}: AnimatedGradientTextProps) {\r\n  const textRef = useRef<HTMLDivElement>(null);\r\n  const animationEnabledRef = useRef<boolean>(true);\r\n\r\n  // Use our performance optimization hook\r\n  const {\r\n    isVisibleRef,\r\n    isInViewportRef,\r\n    isLowEndDevice,\r\n    observeElement\r\n  } = usePerformanceOptimization();\r\n\r\n  // Adjust animation duration based on device capability\r\n  const effectiveDuration = isLowEndDevice ? duration * 2.5 : duration * 1.5;\r\n\r\n  // Check if user prefers reduced motion\r\n  useEffect(() => {\r\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\r\n    animationEnabledRef.current = !mediaQuery.matches;\r\n\r\n    const handleChange = () => {\r\n      animationEnabledRef.current = !mediaQuery.matches;\r\n      updateAnimation();\r\n    };\r\n\r\n    mediaQuery.addEventListener('change', handleChange);\r\n    return () => mediaQuery.removeEventListener('change', handleChange);\r\n  }, []);\r\n\r\n  // Set up viewport detection\r\n  useEffect(() => {\r\n    const element = textRef.current;\r\n    if (!element) return;\r\n\r\n    // Use our performance hook's observer\r\n    observeElement(element);\r\n\r\n  }, [observeElement]);\r\n\r\n  // Update animation based on visibility, viewport, and user preferences\r\n  const updateAnimation = useCallback(() => {\r\n    const element = textRef.current;\r\n    if (!element) return;\r\n\r\n    try {\r\n      // Set up the base styles\r\n      element.style.backgroundImage = gradient;\r\n      element.style.backgroundSize = \"200% auto\";\r\n      element.style.backgroundClip = \"text\";\r\n      element.style.webkitBackgroundClip = \"text\";\r\n      element.style.color = \"transparent\";\r\n\r\n      // Always animate for now to ensure it works\r\n      element.style.animation = `gradient-animation ${effectiveDuration}s linear infinite`;\r\n    } catch (error) {\r\n      console.error(\"Failed to update animation:\", error);\r\n    }\r\n  }, [gradient, effectiveDuration]);\r\n\r\n  // Update animation when visibility or viewport status changes\r\n  useEffect(() => {\r\n    // Initial setup\r\n    updateAnimation();\r\n\r\n    // Create an interval to check for changes to isVisibleRef and isInViewportRef\r\n    const checkInterval = setInterval(() => {\r\n      updateAnimation();\r\n    }, 1000); // Check every second\r\n\r\n    return () => {\r\n      clearInterval(checkInterval);\r\n    };\r\n  }, [updateAnimation]);\r\n\r\n  // Update animation when props change\r\n  useEffect(() => {\r\n    updateAnimation();\r\n  }, [gradient, duration, updateAnimation]);\r\n\r\n  return (\r\n    <div\r\n      ref={textRef}\r\n      className={`animated-gradient-text ${className}`}\r\n      style={{\r\n        display: \"inline-block\",\r\n      }}\r\n    >\r\n      {text}\r\n    </div>\r\n  );\r\n});\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/animated-grid-pattern.tsx",
      "content": "\"use client\";\r\n\r\nimport { useEffect, useRef, memo } from \"react\";\r\nimport { usePerformanceOptimization } from \"@/hooks/usePerformanceOptimization\";\r\n\r\ninterface AnimatedGridPatternProps {\r\n  gridSize?: number;\r\n  lineColor?: string;\r\n  lineOpacity?: number;\r\n  lineWidth?: number;\r\n  animationDuration?: number;\r\n  className?: string;\r\n}\r\n\r\n// Memoize the component to prevent unnecessary re-renders\r\nexport const AnimatedGridPattern = memo(function AnimatedGridPattern({\r\n  gridSize = 40,\r\n  lineColor = \"#000000\",\r\n  lineOpacity = 0.1,\r\n  lineWidth = 1,\r\n  animationDuration = 20,\r\n  className = \"\",\r\n}: AnimatedGridPatternProps) {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const animationRef = useRef<number>(0);\r\n  const offsetRef = useRef<number>(0);\r\n  const speedRef = useRef<number>(0.5); // pixels per frame\r\n  // Add these refs at the top level\r\n  const lastDrawTimeRef = useRef<number>(0);\r\n  const frameRateRef = useRef<number>(0);\r\n\r\n  // Use our performance optimization hook\r\n  const { isVisibleRef, isInViewportRef, isLowEndDevice, observeElement } = usePerformanceOptimization();\r\n\r\n  // Initialize frameRateRef based on device capability\r\n  useEffect(() => {\r\n    frameRateRef.current = isLowEndDevice ? 10 : 15;\r\n  }, [isLowEndDevice]);\r\n\r\n  // Adjust grid size and animation speed based on device capability\r\n  const effectiveGridSize = isLowEndDevice ? gridSize * 2 : gridSize;\r\n  const effectiveAnimationDuration = isLowEndDevice ? animationDuration * 2 : animationDuration;\r\n\r\n  useEffect(() => {\r\n    // Calculate speed based on animation duration to make it consistent\r\n    speedRef.current = effectiveGridSize / (effectiveAnimationDuration * 60); // Assuming 60fps\r\n  }, [effectiveGridSize, effectiveAnimationDuration]);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    // Observe the canvas element for viewport visibility\r\n    observeElement(canvas);\r\n\r\n    const ctx = canvas.getContext(\"2d\", { alpha: true });\r\n    if (!ctx) return;\r\n\r\n    // Set canvas dimensions to match parent container\r\n    const resizeCanvas = () => {\r\n      const parent = canvas.parentElement;\r\n      if (!parent) return;\r\n\r\n      const { width, height } = parent.getBoundingClientRect();\r\n      const dpr = window.devicePixelRatio || 1;\r\n\r\n      // Set display size (css pixels)\r\n      canvas.style.width = `${width}px`;\r\n      canvas.style.height = `${height}px`;\r\n\r\n      // Set actual size in memory (scaled for retina)\r\n      canvas.width = width * dpr;\r\n      canvas.height = height * dpr;\r\n\r\n      // Scale context to match dpr\r\n      ctx.scale(dpr, dpr);\r\n    };\r\n\r\n    // Initial resize\r\n    resizeCanvas();\r\n\r\n    // Add resize listener with debounce\r\n    let resizeTimer: NodeJS.Timeout;\r\n    const handleResize = () => {\r\n      clearTimeout(resizeTimer);\r\n      resizeTimer = setTimeout(resizeCanvas, 200); // Increased debounce time\r\n    };\r\n    window.addEventListener(\"resize\", handleResize);\r\n\r\n    // Draw the grid pattern with throttling\r\n    const drawGrid = (timestamp: number) => {\r\n      if (!ctx || !canvas) {\r\n        animationRef.current = requestAnimationFrame(drawGrid);\r\n        return;\r\n      }\r\n\r\n      // Skip rendering if tab is not visible or element is not in viewport\r\n      if (!isVisibleRef.current || !isInViewportRef.current) {\r\n        animationRef.current = requestAnimationFrame(drawGrid);\r\n        return;\r\n      }\r\n\r\n      // Throttle animation based on frame rate\r\n      const elapsed = timestamp - lastDrawTimeRef.current;\r\n      const frameInterval = 1000 / frameRateRef.current;\r\n\r\n      if (elapsed < frameInterval) {\r\n        animationRef.current = requestAnimationFrame(drawGrid);\r\n        return;\r\n      }\r\n\r\n      // Update last draw time, accounting for the time that passed\r\n      lastDrawTimeRef.current = timestamp - (elapsed % frameInterval);\r\n\r\n      // Clear canvas\r\n      ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);\r\n\r\n      // Set line style\r\n      ctx.strokeStyle = lineColor;\r\n      ctx.globalAlpha = lineOpacity;\r\n      ctx.lineWidth = lineWidth;\r\n\r\n      // Calculate the number of lines needed\r\n      const width = canvas.width / window.devicePixelRatio;\r\n      const height = canvas.height / window.devicePixelRatio;\r\n      const numHorizontalLines = Math.ceil(height / effectiveGridSize) + 1;\r\n      const numVerticalLines = Math.ceil(width / effectiveGridSize) + 1;\r\n\r\n      // Determine line skip factor based on device capability\r\n      const skipFactor = isLowEndDevice ? 3 : 2;\r\n\r\n      // Draw horizontal lines with animation - reduce number of lines for performance\r\n      for (let i = 0; i < numHorizontalLines; i += skipFactor) {\r\n        const y = (i * effectiveGridSize + offsetRef.current) % (effectiveGridSize * numHorizontalLines);\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, y);\r\n        ctx.lineTo(width, y);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // Draw vertical lines with animation - reduce number of lines for performance\r\n      for (let i = 0; i < numVerticalLines; i += skipFactor) {\r\n        const x = (i * effectiveGridSize + offsetRef.current) % (effectiveGridSize * numVerticalLines);\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, 0);\r\n        ctx.lineTo(x, height);\r\n        ctx.stroke();\r\n      }\r\n\r\n      // Update offset for animation - slow down the animation\r\n      offsetRef.current = (offsetRef.current + (speedRef.current * 0.25)) % effectiveGridSize;\r\n\r\n      // Continue animation\r\n      animationRef.current = requestAnimationFrame(drawGrid);\r\n    };\r\n\r\n    // Start animation with timestamp\r\n    animationRef.current = requestAnimationFrame(drawGrid);\r\n\r\n    // Clean up\r\n    return () => {\r\n      window.removeEventListener(\"resize\", handleResize);\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n      }\r\n      clearTimeout(resizeTimer);\r\n    };\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [effectiveGridSize, isLowEndDevice, observeElement]);\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      className={className}\r\n      style={{ display: \"block\", width: \"100%\", height: \"100%\" }}\r\n    />\r\n  );\r\n});\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/shine-border.tsx",
      "content": "\"use client\";\r\n\r\nimport { useEffect, useRef, ReactNode } from \"react\";\r\n\r\ninterface ShineBorderProps {\r\n  children: ReactNode;\r\n  borderColor?: string;\r\n  shineBorderColor?: string;\r\n  borderRadius?: string;\r\n  className?: string;\r\n  duration?: number;\r\n}\r\n\r\nexport function ShineBorder({\r\n  children,\r\n  borderColor = \"rgba(59, 130, 246, 0.2)\",\r\n  shineBorderColor = \"rgba(59, 130, 246, 0.6)\",\r\n  borderRadius = \"0.5rem\",\r\n  className = \"\",\r\n  duration = 3,\r\n}: ShineBorderProps) {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // Add the keyframes animation if it doesn't exist\r\n    if (!document.querySelector(\"#shine-border-keyframes\")) {\r\n      const style = document.createElement(\"style\");\r\n      style.id = \"shine-border-keyframes\";\r\n      style.textContent = `\r\n        @keyframes shine-border {\r\n          0% {\r\n            background-position: 0% 0%;\r\n          }\r\n          100% {\r\n            background-position: 200% 0%;\r\n          }\r\n        }\r\n      `;\r\n      document.head.appendChild(style);\r\n    }\r\n\r\n    // Clean up\r\n    return () => {\r\n      // No cleanup needed for this effect\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={className}\r\n      style={{\r\n        position: \"relative\",\r\n        borderRadius,\r\n        background: `linear-gradient(90deg, ${borderColor} 0%, ${shineBorderColor} 50%, ${borderColor} 100%)`,\r\n        backgroundSize: \"200% 100%\",\r\n        animation: `shine-border ${duration}s linear infinite`,\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          borderRadius: `calc(${borderRadius} - 1px)`,\r\n          overflow: \"hidden\",\r\n        }}\r\n      >\r\n        {children}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/ui/scroll-progress.tsx",
      "content": "\"use client\";\r\n\r\nimport { useEffect, useState } from \"react\";\r\n\r\ninterface ScrollProgressProps {\r\n  color?: string;\r\n  height?: number;\r\n  zIndex?: number;\r\n}\r\n\r\nexport function ScrollProgress({\r\n  color = \"#3b82f6\",\r\n  height = 4,\r\n  zIndex = 50,\r\n}: ScrollProgressProps) {\r\n  const [scrollProgress, setScrollProgress] = useState(0);\r\n\r\n  useEffect(() => {\r\n    const handleScroll = () => {\r\n      const totalHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;\r\n      const progress = (window.scrollY / totalHeight) * 100;\r\n      setScrollProgress(progress);\r\n    };\r\n\r\n    // Add scroll event listener\r\n    window.addEventListener(\"scroll\", handleScroll);\r\n\r\n    // Initial calculation\r\n    handleScroll();\r\n\r\n    // Clean up\r\n    return () => {\r\n      window.removeEventListener(\"scroll\", handleScroll);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        position: \"fixed\",\r\n        top: 0,\r\n        left: 0,\r\n        right: 0,\r\n        height: `${height}px`,\r\n        backgroundColor: \"transparent\",\r\n        zIndex,\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          height: \"100%\",\r\n          width: `${scrollProgress}%`,\r\n          backgroundColor: color,\r\n          transition: \"width 0.1s ease-out\",\r\n        }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/magicui/ripple.tsx",
      "content": "import React, { ComponentPropsWithoutRef, CSSProperties } from \"react\";\n\nimport { cn } from \"@/lib/utils\";\n\ninterface RippleProps extends ComponentPropsWithoutRef<\"div\"> {\n  mainCircleSize?: number;\n  mainCircleOpacity?: number;\n  numCircles?: number;\n}\n\nexport const Ripple = React.memo(function Ripple({\n  mainCircleSize = 210,\n  mainCircleOpacity = 0.24,\n  numCircles = 8,\n  className,\n  ...props\n}: RippleProps) {\n  return (\n    <div\n      className={cn(\n        \"pointer-events-none absolute inset-0 select-none [mask-image:linear-gradient(to_bottom,white,transparent)]\",\n        className,\n      )}\n      {...props}\n    >\n      {Array.from({ length: numCircles }, (_, i) => {\n        const size = mainCircleSize + i * 70;\n        const opacity = mainCircleOpacity - i * 0.03;\n        const animationDelay = `${i * 0.06}s`;\n        const borderStyle = i === numCircles - 1 ? \"dashed\" : \"solid\";\n        const borderOpacity = 5 + i * 5;\n\n        return (\n          <div\n            key={i}\n            className={`absolute animate-ripple rounded-full border bg-foreground/25 shadow-xl`}\n            style={\n              {\n                \"--i\": i,\n                width: `${size}px`,\n                height: `${size}px`,\n                opacity,\n                animationDelay,\n                borderStyle,\n                borderWidth: \"1px\",\n                borderColor: `hsl(var(--foreground), ${borderOpacity / 100})`,\n                top: \"50%\",\n                left: \"50%\",\n                transform: \"translate(-50%, -50%) scale(1)\",\n              } as CSSProperties\n            }\n          />\n        );\n      })}\n    </div>\n  );\n});\n\nRipple.displayName = \"Ripple\";\n",
      "type": "registry:component"
    }
  ]
}